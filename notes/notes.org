* board
- put metadata in yaml. yaml-cpp
- how to link my lidar_sim libraries

- hg sim timing
  - takes 10s to load section 4 sim
  - serial sim time is 2s/packet
- mm sim timing
  - takes 60s to load section 4 sim
  - version 010218 takes 16s to load section 4 sim
  - currently sim takes 20s/packet
  - version 010218 takes ~6s/packet. still 2.5x slower than hg. try reducing
    meshes further, then.

- mm sim meshes
  - removed heavy meshes from elements and reduced to 0.1 to create
    mm_version 070218. but even it took ~5s/packet. so going ahead with 010218
    for now.
  - after using flann dataset wrapper for objects near mesh, ~4s/packet, minor
    improvement

- omp
  - currently doing presim operations in serial. with section 4 scans version
    260118, presim takes ~2s for 1k packets. for scans version 300118 it takes
    ~16s/1k packets. why? this implies total presim time for 300118 expected to
    be ~15min (actually is 18min), negligible compared to overall sim time.
  - section 4. scans version 260118. hg 500 packets. (threads, time in s). (8,
    344). (6,376). (4,514). (2,688). (1,1036).
  - section 4. scans version 260118. mm 200 packets. (threads, time in s). (8,
    358). (6,397). (4,561). (2,733). (1,1227).
    
- sim memory leak
  - destorys execution of mm for large number of packets
  - first, i added the use of flann dataset wrapper for MeshModelSim, to find
    nearest mesh objects. earlier i was building index each time
  - then, i removed the uses of new while creating flann matrices
  - then, i removed the use of stlArrayToFlannMatrix. because i was using a
    local variable to create the flann matrix, which was going out of scope.

- memory use is already high during presim. solution? some data, eyeballed from
  top. section 4, scans version 300118. (min, mem%).
  - mm. (5, 15). (8, 20.5). (10, 24.3). (12,
    28.2). (13, 30). (14, 32). (15, 34). (18, 40). overall around 18min.
  - hg. (6, 17). (12, 28.8). (14, 32.7). (16, 36.7). so similar use.

- more top eyeballing. section 4, scans version 300118. (min, mem%).
  - (45, 55.4). (200, 56). (417, 57.8). (642, 58.5). (1000, 61). (1243, 63.2).
    (1908, 64.7). (2293, 66). (2523, 44) drop probably because i threw in a
    compile. (2591, 44.5) not sure why it became tame, because processor doing
    other things?. (7046, 64.7). (7398, 68). (7416, 51.6) again, reduced because
    i compiled, maybe some cleanup is done. (7746, 54.3). (8712, 49.4) in check
    because valgrind is also running. (9197, 52.5). (10836, 54).

- profiling
  - perf, operf for who is taking long etc
  - look up nvidia optix for raytracing

- aggregating scans version 300118 took 1079s = ~18min.

- running 100 params for hg scans took 2132s = 35min
- running 100 params for hg scans took 2944s = 49min

* mat

- grep todos in code

- maybe instead of making cell blocks inside a long function, write subfunctions.

- primitives pipeline
  - create a version folder in the appropriate section dir
  - make primitive directories
    - also for figures
  - construct primitives
  - generate figures of primitives
    - also not a bad idea to calculate primitive stats
  - specify element ids to sample from
    - opportunity to weed out bad primitives

- new scene sim pipeline
  - perform non/ ground segmentation
  - gen imu posn nodes

    posn nodes can be stored in the section folder
  - build ground blocks. build ground block models. these are shared by hg and
    mm sim

    the blocks, and the block node ids, can be stored in
    section_folder/hg_sim/blocks_info. note that the blocks are indexed starting
    from 1. this is a relic convention and should be overhauled

  - get annotations from labeling
  - construct hg scene objects
  - create ellipsoid blocks
  - create mm meshes
  - todo
    - create corresponding hg version dir in cpp
    - move block info non ground to hg version, not blocks info
    - script to copy ground triangles, which are retained
  - reduce tri models for viewing in rviz

- include short descriptions for each script

* analyze taylor data

- imu frame s.t. vehicle moves along -ve y
- laser frame s.t. vehicle moves along +ve x

- camera ids: clock-hour orientation, 12 is straight ahead

79: 10
80: 12
81: 4
82: 2
83: 8
84: 6

- num frames:
38384, 38384, 6242, 6242, 6224, 7989

- num velodyne packets: 4624457

- brigthened image by contrast. how it works is a mystery to me.

- scatter3 can handle about a max of 1e5 points smoothly. 

- section number-name mapping
1: loop A
2: loop A
3: rim stretch
4: loop B
5: loop B
6: loop C
7: loop C
8: rim stretch
9: loop D
10: loop D
11: loop C'
12: rim stretch
13: loop A
14: loop A

- time extents
  - section 1: [1403045583 1403045649]
  - section 3: [1403045836 1403045903]
  - section 4: [1403045920 1403046033]

* hybrid geometric sim

- sortintersectionflag used by mesh and ellipse, might want to change comments

- remember that values of segmentationparams depend on point cloud density,
e.g. max dist to nbrs or min nbrs. segmentation works with subsampled
dataset. so will have to transfer labels to points in full dataset, just do
nearest neighbors

- block_node_ids format

  [block_id_start block_id_end]. where the ids are of the imu position nodes

* scenes labeling

- labeling

the tape is broken

- in what format do you want labeling results to be in finally?

one file, contains labelings, semgentIds. combine this with the segment pts

- manual segmentation pipeline
  - ground segmentation
    - by which is meant separation into ground and non-ground
    - results stored in lidar_sim/cpp/data/sections/section_xx/ground_segmentation
    - load pts into cloudcompare, divide into parts
    - delete non-ground segments generated in cloud compare, script later derives them.
    - finally fuse into section_pts_xx_ground.asc
  - non-ground segmentation
    - results in lidar_sim/cpp/data/sections/section_xx/non_ground_segmentation
    - section_pts_xx_non_ground is an output from ground segmentation
    - divide into parts, folder for each part
    - numbered segments in each part folder
    - keep saving intermediate results
  - labeling
    - save segmented pts as mats
    - use the labeling tool
    - save in data/sections/section_xx/labeling/labeling_for_segment_ids
      - todo
      - variables 'labeling' and 'segmentIds'

* cpp

- cpp11
  - auto
  - lambda expressions
  - for_each
  - initializations
  - set functions. like intersections etc

- simplifying sim creation code

- todo: add progress bars to your sim codes

- grep todos

- just like you have functions written in matlab for matlab processing, you need
to write emacs lisp to do simple operations in emacs

- better implementation of vector to eigen, vector to flann, etc, than your
copying code

- write good code comments

- tools for slow code
boost scope cpu timer
valgrind

- in a class, one function after another, only operating on member data, who knows
what comes when?

- ray nn

major overhaul. affects hit prob calc etc

- one of the sources of error is that the imu posn is not the laser posn!

- how to save objects? boost serialize

- i want to throw away visualizer.cpp and pcl includes in cmakelists, but for
unidentified reason, just commenting out visualizer breaks compilation in ways
related to vtk and boost.

- cpp pretty printing

- nomenclature for model etc is completely lost and mixed up

- sim versions

ideally for each version file, write the parameters. maybe have each class
return its parameters values as a string. and then some top level thing gathers
them and writes them out? so that you don't have to keep track of them.

- times
  - hg sim 1750 packets takes 3hr
  - mm sim 1750 packets takes 8hr
  - build_models_non_ground_blocks version_310817 took 1hr
  - hg_sim section 8 takes 1.5hr
  - clustering s3 b10, 30k points. both flann and alglib take 2min.
  - with secn3 subsampled, packet step 10, creating sim detail template takes 8min.
  - sec1 sim with packet skip 10, mm 130917 takes 3.5hr, hg takes 130917 15min

- a config helper
  - i guess ideally, a class like OptimAssistant, doesn't deal so extensively
    with parameters. they are instead read from a config file. and there are
    scripting tools to manage the config file. for example, go into python and
    tweak values there. since the python script has the semantic knowledge also
    of what is what, it will have no trouble outputing it as xml, txt, etc etc.

* analyze taylor data:

- other logic from ref: don't include points too close, speed of vehicle etc.

- everywhere in my code, the pose convention is : yzxrpy, and the yaw has to be
-ve for using in a transformation

------------------------------

* vtk

- add features
axes ticks
subfigures
labels
viewpoints
saving figures

- why does viz ellipsoids need one at the origin?

- vtk bulbs when giving it only sim points, why?

------------------------------

* hybrid geometric sim:

- implementations of hierarchical clustering other than alglib. flann has one.

- for intersection with triangles, there is a smarter way to line walk instead
  of checking with all triangles

- alglib rbf fit slow. 

for rim stretch ground train, with 1e6 pts, takes 729 s with rbfdist = 1, level
= 1, smoothness = 1e-3 10s with radius = 0.1m.

- how does matlab manage griddata fast? probably does it only for query
  points. matlab pdist2 very fast compared to for looping cpp

- many class members are public. so there was an error in the rng in
eigenmvn. watch out, there could be similar errors in the rest of the code

- flann includes pt as its own nearest nbr

- saw error due to playing around too much with private variables. m_n_clusters
error happened. what is a good way to avoid that error.

- deterministic simulation is useful for debugging. 

where is randomnness in sim?

triangles: sample hit id, add gaussian noise to range

ellipsoid: sample hit id, draw from ellipsoid mvn

- note that all the sims being compared should use the same tranining data

  this means that the nbr sim uses the same training section pts as hg sim

- flann nn dists are distance squared

--------------------------------------------------

* cloudcompare installation

- installed qt5.7 via instructions from 
  https://wiki.qt.io/Install_Qt_5_on_Ubuntu
eventually files in ~ instead of /usr/local

- git cloned cloudcompare and followed instructions on BUILD.md

- used cmake gui to configure and generate. make of cloudcompare was not finding
  qt5.7

- changed qt default
http://askubuntu.com/questions/435564/qt5-installation-and-path-configuration

- this made it seem like 5.7 was being used, but compile still failed.

- in cmake gui, changed the qt root path + qt cmake refs to the directories in ~
which worked

--------------------------------------------------

* ros 

- installing indigo on cmu desktop. when installing desktop-full, had problems
  with installing the simulators. a gazebo bug is noted on the website. i
  deleted all gazebo-7 filed i had, yet didn't go away. installing only desktop
  for now, since i mainly need rviz.

- had catkin under git, which was wrong. split each package into a repo. for
  sanjiban's ones, i need to set an upstream.

- repos forked from humhu. catkin makes
  - odoscan
  - argus_utils
  - rosbag_lib. not somethiing we can merge? ask
  - infitu
  - fieldtrack

- after installing humhu's packages, did rospack profile.
- why doesn't odoscan/cloud_features_node show up on tab-complete?
- ros packages can be in subdirs, what matters is having the
  cmakelists.txt and the package.xml

* soup up laptop 

- increasing space for ubuntu. both / and /home needed more space. more space
  was available in a drive used by windows. the space was positioned as windows
  space, linux root, linux home. i used a bootable gparted usb to make the
  changes. i had to make changes to the thinkpad bios to get it to boot from
  usb. secure boot: disable. and then boot from uefi and legacy both. i created
  the bootable usb using tuxboot.

- cloudcompare installation was very easy. because now it can be done via snap.

- alglib. copies files from desktop

- eigenmvn. copied files from desktop

- flann seems to be present in /usr/include

- cgal. installed via apt.

- nlopt. installed as per website instructions.

- boost filesystem needed extra handling with cpp11

- compilation was maxing out memory. so i added 10gb from home to swap. 

- ros. i installed kinetic on laptop. i cloned the catkin, but it doesn't seem
  to work. will have to read about how correctly to use ros with git.

* algo state estimation

- ideally should be own repo/ codebase. practice for linking your lidar_sim
  libraries too.
- created nested namespace, but this could also be its own namespace

- process info format
  - source section file
  - n scans
  - packets per scan
  - skip within scan
  - skip between scans

- need tabs for
  - roscore
  - rviz
  - catkin_make
  - roslaunch
  - rosservice call. or python run_odoscan
  - rostopic, rosbag
  - ipython

- for creating sim packets, the code for hg and mm is exactly the same, except
  the sim object creation portions. so need 2 things. first, helper functions
  for creating the appropriate sim objects. this is in your control. second, one
  cpp code, which can then take arguments/ function/ handles of some form. get
  help on the second.

- the sim scans look very clean compared to reality. part of this is not enough
  surrounding vegetation. but what about the ground?

- while aggregating mm, expected scans didn't much num scans. i think that some
  packets were entirely not written, since there were no hit points there.

** sim versions

- hg_sim
  - version 080917

- mm_sim
  - version 010218
